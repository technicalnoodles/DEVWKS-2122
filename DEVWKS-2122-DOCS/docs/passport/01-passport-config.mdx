---
sidebar_position: 1
---

# WebEx OAuth & Passport

Passport is an authentication library that can be put into any JavaScript application using `Express`. The Passport webpage is [here](https://www.passportjs.org/).

If you look at the Passport webpage, you will notice they mention they use `Strategies`. A strategy is their way of saying a process for authenticating to a service has been coded and made into a module for ease of use.

We will be using the `Cisco - Spark` [strategy](https://www.passportjs.org/packages/passport-cisco-spark/) in our application. But you can use any of the other ones they have too. Some examples are Facebook, Google, GitHub, LinkedIn, and the list can go on. But they will all work in the same way the Cisco strategy does.

## Passport Configuration

We will configure the passport _service_ the web application will use and create the _authentication_ routes needed to fullfill the authentication flow.

### Passport Service

The Passport service is the configuration we need to be able to run this library and use the `cisco-spark` strategy. It will then be passed to the main application to be mode available to the rest of the applicaiton functions.

In the `services` directory, make a file called `passport.js` if it does not already exist.

Open this file in the Visual Studio Code(VSCode) editor.

The below code is what will be pasted into the `passport.js` file.

```javascript title=services/passport.js showLineNumbers
const passport = require('passport');
const CiscoStrategy = require('passport-cisco-spark').Strategy;
const mongoose = require('mongoose');
const keys = require('../config/keys');

const User = mongoose.model('users');

passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser((id, done) => {
  User.findById(id).then((user) => {
    done(null, user);
  });
});

passport.use(
  new CiscoStrategy(
    {
      clientID: keys.ciscoClientID,
      clientSecret: keys.ciscoClientSecret,
      callbackURL: '/auth/cisco/callback',
    },
    (accessToken, refreshToken, profile, done) => {
      console.log(profile);
      User.findOne({
        ciscoId: profile['_json']['userName'],
      }).then((existingUser) => {
        if (existingUser) {
          done(null, existingUser);
        } else {
          new User({
            ciscoId: profile['_json']['userName'],
            name: profile['_json']['displayname'],
            departmentId: profile['_json']['department'],
          })
            .save()
            .then((user) => done(null, user));
        }
      });
    }
  )
);
```

In the above code, we tell the imported Passport library to use a new `CiscoStrategy`. We give the `CiscoStrategy` one argument with a few different fields, `clientID`, `clientSecret`, and `callbackURL`. The two client values are used by the server to make the call to our integration and the `callbackURL` URL is used by the integration so it knows who to send the data back to.

Our `callbackURL` is the same as the `Redirect URI` we created in the Webex Integration.  
:::info
The `callbackURL` and the `Redirect URI` must match otherwise WebEx will not allow the flow to continue. This is to prevent anyone from trying to take over the session.
:::

The second argument of the `CiscoStrategy` is a callback function. The callback function has four inputs, `accessToken`, `refreshToken`, `profile`, and `done`
Once a successful authentication request occurs, this callback function is called, and we can then store the information we want.

To serialize a user, there is a function that Passport provides to us called `serializeUser`. It takes a callback function with two arguments: `user` and `done`. The user is the `user` we got back from mongoose. We will be adding this function right below the `User` model declaration.

Deserializing is like serializing a user. The difference being we need to first find the `user` from the database before we can deserialize them. the function is call `deserializeuser` and instead of taking a `user` object, it takes an `id`. The `id` will be used to find the user with mongoose.

### Authentication Routes

The authentication routes will be used to send authentication requests to different services and to receive these services responses.
To create them, we need to make a new file in the `routes` directory called `authRoutes.js` if it does not already exist.

After it has been created, let's open that file in VSCode. You can paste the below code into the `authRoutes.js` file.

```javascript title=routes/authRoutes.js showLineNumbers
const passport = require('passport');

module.exports = (app) => {
  app.get(
    '/auth/cisco',
    passport.authenticate('cisco-spark', { scope: ['spark:all'] })
  );

  app.get(
    '/auth/cisco/callback',
    passport.authenticate('cisco-spark'),
    (req, res) => res.redirect('http://localhost:3000/events')
  );

  app.get('/api/logout', (req, res) => {
    req.logout(function (err) {
      if (err) {
        return next(err);
      }
      res.redirect('http://localhost:3000/');
    });
  });

  app.get('/api/current_user', (req, res) => {
    res.send(req.user);
  });
};
```

Looking at the top route. We are expecting a `GET` request for `/auth/cisco`. When we see this request we will forward the request to Passport to start the authentication flow. The first argument for the authentication request is what strategy it will use. This one will use the `cisco-spark` strategy.

The second argument is the `scope` of what data we want to get back from the authentication request. In this case, it is the same `scope` we defined in the Webex Integration. This first request that is sent to WebEx will return a `code` like we saw in the OAuth flow, but no user data. The `code` is like a ticket.

We will exchange this ticket for the user data in the callback. Here is an example of what is returned as a URL:
`http://localhost:5000/auth/cisco/callback?code=YjJkNzdlOWItMTJ0000000000000000000000000000000000000_PF84_1eb65fdf-9643-417f-9974-ad72cae0e10f`

The second route is the route we are using as the callback for the integration. This callback route will make another call back to WebEx, but it will pass the `code` from the previous request as an argument. Now that we have given the ticket back to WebEx, it will give us the user data we requested. This second route is needed to finish the OAuth flow.

The route `/api/logout` will be used to take care of logouts and it will tear down the session and invalidate the cookie at the same time.

Finally, we need an API to check if there is a user logged in. The `/api/current_user` route will provide this functionality. It is what our frontend will use to check if it can say someone is logged in or not as well.

Before testing the flow, let us configure the main applicaiton to use what we have setup and to allow cookies to be used for a user session.
